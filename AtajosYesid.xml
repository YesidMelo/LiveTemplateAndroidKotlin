<templateSet group="AtajosYesid">
  <template name="alertaCalendario" value="&#10;//Manejo calendario&#10;fun dialogoCalendario( accion:((Int,Int,Int)-&gt;Unit) ?= null,minDate : Date? = null, maxDate:Date?= null) {&#10;        val calendar = GregorianCalendar()&#10;        class Accion:DatePickerDialog.OnDateSetListener{&#10;            override fun onDateSet(p0: DatePicker?, p1: Int, p2: Int, p3: Int) {&#10;                accion?.invoke(p1, p2, p3)&#10;            }&#10;        }&#10;        val dialog=DatePickerDialog(this,&#10;                Accion(),&#10;                calendar.get(Calendar.YEAR),&#10;                calendar.get(Calendar.MONTH),&#10;                calendar.get(Calendar.DAY_OF_MONTH))&#10;        if(minDate != null){&#10;            dialog.datePicker.minDate= minDate.time&#10;        }&#10;        if(maxDate != null){&#10;            dialog.datePicker.maxDate= maxDate.time&#10;        }&#10;        Log.e(&quot;&quot;,&quot;&quot;)&#10;        dialog.show()&#10;    }&#10; // fin manejador calendario" description="Crea una alerta de calendario elemental" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="lectorJSON" value="/**&#10; * Funcion encargada de leer un archivo .json de la carpeta assets&#10; * de la aplicacion&#10; * */&#10;&#10;fun lectorJSON (@NotNull nombreArchivo:String,@NotNull context: Context):String?{&#10;    var json :String ?= null&#10;    try {&#10;        val documento= context.assets.open(nombreArchivo)&#10;        val tamanio = documento.available()&#10;        val buffer = ByteArray(tamanio)&#10;        documento.read(buffer)&#10;        documento.close()&#10;        json = String(buffer,Charsets.UTF_8)&#10;        return json&#10;    } catch (e: Exception) {&#10;        Log.e(&quot;Error&quot;,Log.getStackTraceString(e))&#10;        return null&#10;    }&#10;}" description="Lee un documento json de la carpeta assets" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="redimencionarImagen" value="@RequiresApi(Build.VERSION_CODES.LOLLIPOP)&#10;fun redimencionaUnaImagen(context: Context, rutaAncho: Int, rutaAlto: Int, rutaImage: Int): Drawable {&#10;    val imagenOriginal = (context.getDrawable(rutaImage) as BitmapDrawable).bitmap&#10;    val imagenRedimencionado = Bitmap.createScaledBitmap(&#10;            imagenOriginal,&#10;            context.resources.getDimension(rutaAncho).toInt(),&#10;            context.resources.getDimension(rutaAlto).toInt(),&#10;            false)&#10;    return BitmapDrawable(context.resources, imagenRedimencionado)&#10;}" description="funcion encargada de redimencionar una imagen por codigo" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="expreg" value="/**&#10; * Funcion encargada de evaluar si un estring cumple con los estandares de una expresion regurlar&#10; */&#10;fun validarConExpresionReg(aEvaluar: String, expresionRegular: ExpresionRegular): Boolean {&#10;    val patern = Pattern.compile(expresionRegular.expresion)&#10;    val matcher = patern.matcher(aEvaluar)&#10;    return matcher.find()&#10;}&#10;&#10;/**&#10; * Expreciones regulares&#10; */&#10;enum class ExpresionRegular(val expresion: String) {&#10;    EMAIL(&quot;^[_a-z0-9-]+(.[_a-z0-9-]+)*@[a-z0-9-]+(.[a-z0-9-]+)*(.[a-z]{2,4})$&quot;)&#10;}" description="Funcion y constantes para validar expresiones regulares" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="igualaView" value="@SuppressLint(&quot;ObsoleteSdkInt&quot;)&#10;/**&#10; * funcion encargada de igualar el tamaño de dos vistas&#10; * */&#10;&#10;fun igualaTamanioVistas(@NotNull original:View,@NotNull aRedimencionar:View){&#10;    val vto = original.viewTreeObserver&#10;    class Accion:ViewTreeObserver.OnGlobalLayoutListener{&#10;        override fun onGlobalLayout() {&#10;            if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) {&#10;                original.viewTreeObserver.removeGlobalOnLayoutListener(this)&#10;            } else {&#10;                original.viewTreeObserver.removeOnGlobalLayoutListener(this)&#10;            }&#10;            val width = original.measuredWidth&#10;            val height = original.measuredHeight&#10;            val params = RelativeLayout.LayoutParams(width, height)&#10;            aRedimencionar.layoutParams = params&#10;        }&#10;&#10;    }&#10;    vto.addOnGlobalLayoutListener(Accion())&#10;}" description="Funcion encargada de igualar el tamaño de dos view" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="conexionInternet" value="&#10;/**&#10; * Verifica tipo conexion a internet&#10; * En el manifiest:&#10; * &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt;&#10; *  &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#10; */&#10;fun tipoConexionInternet(context: Context): TipoConexionInternet {&#10;    val conexion: ConnectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager&#10;    if (conexion.activeNetworkInfo != null &amp;&amp; conexion.activeNetworkInfo.type == ConnectivityManager.TYPE_WIFI) {&#10;        return TipoConexionInternet.WIFI&#10;    }&#10;    if (conexion.activeNetworkInfo != null &amp;&amp; conexion.activeNetworkInfo.type == ConnectivityManager.TYPE_MOBILE) {&#10;        return TipoConexionInternet.DATOS&#10;    }&#10;    return TipoConexionInternet.SIN_CONEXION&#10;}&#10;&#10; /**&#10; * Tipos de conexion a internet&#10; */&#10;enum class TipoConexionInternet() {&#10;    SIN_CONEXION,&#10;    WIFI,&#10;    DATOS,&#10;}" description="Verifica si el dispositivo esta conectado a internet" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="adicionaTiempo" value="/**&#10; * funcion encargada de adicionar o quitar tiempo de una fecha&#10;*/&#10;&#10;fun adicionaQuitaTiempo(@NotNull adicionar:TipoAdicion,@NotNull date:Date ,@NotNull periodo:Int):Date{&#10;    val calG = GregorianCalendar()&#10;    calG.time=date&#10;    when(adicionar){&#10;        TipoAdicion.DIAS_MES-&gt;{&#10;            calG.add(Calendar.DAY_OF_MONTH,periodo)    &#10;        }&#10;        TipoAdicion.MESES-&gt;{&#10;            calG.add(Calendar.MONTH,periodo)    &#10;        }&#10;        TipoAdicion.ANIOS-&gt;{&#10;            calG.add(Calendar.YEAR,periodo)    &#10;        }&#10;        TipoAdicion.SEMANAS-&gt;{&#10;            calG.add(Calendar.WEEK_OF_YEAR,periodo)    &#10;        }&#10;        TipoAdicion.DIAS_ANIO-&gt;{&#10;            calG.add(Calendar.DAY_OF_YEAR,periodo)    &#10;        }&#10;    }&#10;    return  calG.time&#10;}&#10;&#10;enum class TipoAdicion{&#10;    DIAS_MES,&#10;    MESES,&#10;    ANIOS,&#10;    SEMANAS,&#10;    DIAS_ANIO,&#10;}" description="Funcion encargada de adicionar o quitar periodos de tiempo a un date" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="conversorDeJson" value="/***&#10;     * Poner la libreria en el gradle&#10;     * implementation 'com.google.code.gson:gson:2.8.5'&#10;     * Convierte un JSONArray a un arreglo de objetos&#10;     */&#10;    fun &lt;K : Any?&gt; JSONArrayToArrayObject(@NotNull json:String,@NotNull clase:Class&lt;K&gt;):MutableList&lt;K&gt;?{&#10;        val jsonArray = JSONArray(json)&#10;        var list :MutableList&lt;K&gt; = emptyList&lt;K&gt;().toMutableList()&#10;        try {&#10;            val gson = Gson()&#10;            for (contador in 0 until jsonArray.length()) {&#10;                val tmp = gson.fromJson(jsonArray[contador].toString(), clase)&#10;                list.add(tmp)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;Error&quot;,Log.getStackTraceString(e))&#10;            list = emptyList&lt;K&gt;().toMutableList()&#10;        }&#10;        return list&#10;    }&#10;&#10;    /**&#10;     * Convierte un objetojson a un object&#10;     */&#10;    fun &lt;T:Any?&gt; JSONObjectToObject(@NotNull json:String,@NotNull clase : Class&lt;T&gt;):Any?{&#10;        return try {&#10;            val gson =Gson()&#10;            gson.fromJson(json,clase)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;Error&quot;,Log.getStackTraceString(e))&#10;            null&#10;        }&#10;    }" description="Convierte de json a un objeto o arreglo de objetos" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="bitmapRedimencion" value="@SuppressLint(&quot;ResourceType&quot;)&#10;fun redimenBitmapDescriptorFactory(@NotNull context: Context, @NotNull @IntegerRes pathImage:Int, @NotNull @IntegerRes pathWith:Int, @NotNull @IntegerRes pathHeigth:Int):BitmapDescriptor?{&#10;    var ImagenOriginal:Bitmap? = BitmapFactory.decodeResource(context.resources, pathImage)&#10;    if (ImagenOriginal == null){&#10;       ImagenOriginal = convertDrawableShapeToBitmap(context,pathImage)&#10;    }&#10;    val redimencion: Bitmap = Bitmap.createScaledBitmap(ImagenOriginal!!,context.resources.getDimension(pathWith).toInt(),context.resources.getDimension(pathHeigth).toInt(),false)&#10;    val original  = BitmapDescriptorFactory.fromBitmap(redimencion)&#10;    return original&#10;}" description="Redimenciona un bitmap usando los recursos" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
  <template name="drawableToBitmap" value="@SuppressLint(&quot;ResourceType&quot;)&#10;fun convertDrawableShapeToBitmap(@NotNull context: Context, @NotNull @IntegerRes pathImage:Int):Bitmap{&#10;    val drawable:Drawable = context.resources.getDrawable(pathImage)&#10;    val canvas = Canvas()&#10;    val bitmap = Bitmap.createBitmap(drawable.intrinsicWidth,drawable.intrinsicHeight,Bitmap.Config.ARGB_8888)&#10;    canvas.setBitmap(bitmap)&#10;    drawable.bounds.set(0,0,drawable.intrinsicWidth,drawable.intrinsicHeight)&#10;    drawable.draw(canvas)&#10;    return bitmap&#10;}" description="Convierte un drawable de los recursos en un bitmap" toReformat="false" toShortenFQNames="true">
    <context>
      <option name="KOTLIN" value="true" />
    </context>
  </template>
</templateSet>